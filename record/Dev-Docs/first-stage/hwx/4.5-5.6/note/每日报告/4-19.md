é¦–å…ˆä¸€ç‚¹ï¼šæˆ‘è®¤ä¸ºagent-clientè¿™ä¸ªåŒç«¯æ¦‚å¿µéå¸¸é‡è¦

### clientç«¯è¿½è¸ª

### PrioTable

è¿™ç§ç±»æ˜¯ç”¨æ¥store sched itemçš„ä¸€ä»½copyçš„

```c++
// To use, create an instance of this class and call 'SeqCopyParams' with the
// sched item's corresponding 'sched_item' and 'work_class'.
```

å®ƒé‡Œé¢ä¸€èˆ¬è¿˜ä¼šæœ‰ä¸ª`SeqCopyParams`æ–¹æ³•

```c++
class SchedParams {
```

### RocksDB

æˆ‘å‘ç°shinjukué‚£ä¸ªç­–ç•¥æè¿°çš„å°±æ˜¯æˆ‘ä»¬é›†ä¸­å‹çš„fifo schedulerï¼ï¼ï¼

ä¸€ä¸ªåˆ†å‘ä»»åŠ¡çš„dispatcher threadï¼Œå®ƒä¸ä¸€ä¸ªCPUé”æ­»ï¼›è¿˜æœ‰è®¸å¤šworker threadï¼Œå®ƒä»¬ç­‰å¾…dispatcheråˆ†é…ä»»åŠ¡ï¼Œå¹¶ä¸”å®ƒä»¬ä¹‹é—´æ˜¯é‡‡ç”¨FIFO+æ—¶é—´ç‰‡è°ƒåº¦çš„ã€‚è¿™æ­£tmæ˜¯æˆ‘ä»¬çš„centralized FIFOï¼

è®ºæ–‡ä¸­rocksdbä¼¼ä¹æ˜¯ç”¨äºshinjukuç­–ç•¥é‚£è¾¹çš„ã€‚å®ƒé‡Œé¢çš„å…·ä½“workloadè¡¨è¿°ï¼š

**Single Workload** 

> As in the Shinjuku [25] paper, we generate a workload in which each request includes a GET query to an in-memory RocksDB key-value store [70] (about 6 *ğœ‡*s) and performs a small amount of processing. 
>
> workloadï¼šæ¯æ¬¡è¯·æ±‚åŒ…å«ä¸€æ¬¡å¯¹å†…å­˜ä¸­RocksDB key-valueæ•°æ®çš„æŸ¥è¯¢ï¼ˆè¦æ±‚æŸ¥è¯¢æ—¶é—´åœ¨6Î¼så†…ï¼‰ï¼Œå¹¶ä¸”è¿›è¡Œå°è§„æ¨¡è¿ç®—ã€‚
>
> We assigned the following processing times: 
>
> æˆ‘ä»¬åˆ†é…äº†å¦‚ä¸‹çš„å¤„ç†æ—¶é—´ï¼š
>
> 99.5% of requests - 4 *ğœ‡*s, 0.5% of requests - 10 ms. 
>
> The allotted timeslice per worker thread, before forcing a preemption and returning back to the FIFO, is 30 *ğœ‡*s.
>
> æ¯ä¸ªworker threadçš„æ—¶é—´ç‰‡ä¸º30Î¼s
>
> CFS-Shinjuku is non-preemptive, so all requests run to completion.

**Multiple Workloads Comparison**

> In a production scenario, when RocksDB load is low, it is appealing to use the idling compute resources to serve low-priority batch applications [1, 21, 71] or run serverless functions. 
>
> ç”Ÿäº§å®è·µä¸­ï¼Œå½“RocksDBçš„è´Ÿæ‹…å°ï¼Œå°±ä¼šä½¿ç”¨ç©ºé—²çš„èµ„æºå»åšä½ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚
>
> The original Shinjuku system schedules requests and cannot manage any other *native* threads. Fig. 6c shows that when we co-locate a batch application with a RocksDB workload managed by Shinjuku, the batch application cannot get *any* CPU resources even when the RockDB load is low.
>
> åŸæ¥çš„shinjukuä¸è¡Œ





è¿™ä¸ªç©æ„ç”¨æ¥ç®¡ç†å››ä¸ªä¸œè¥¿ï¼š

1. clientä¸agentçš„é€šä¿¡ï¼ˆfutex or prio tableï¼‰
2. load generator
3. dispatcher
4. workers

```c++
// Manages communication with the scheduled application via the PrioTable.
// To use, construct the class and call 'Init' with the application's PID.
class Orchestrator {
    
// Options options;
// ... Fill in the options.
// GhostOrchestrator orchestrator_(options);
// (Constructs orchestrator with options.)
// ...
// orchestrator_.Terminate();
// (Tells orchestrator to stop the experiment and print the results.)
```

kBackgroundThreadCpuæ˜¯ä»€ä¹ˆï¼Ÿæ˜¯load generator+dispatcherå—

![image-20230420144534204](./4-19/image-20230420144534204.png)

é‚£ä¹ˆghostçš„agentæ˜¯åœ¨å“ªå®ç°çš„ï¼Ÿ

æ˜¯æ€ä¹ˆåšåˆ°â€œload generatorè°ƒåº¦åœ¨CFSï¼Œworkerè°ƒåº¦åœ¨ghostâ€è¿™ç§åˆ†ç±»çš„ï¼Ÿæ˜¯ç”¨çš„`GhostThread`ç±»å—ï¼Ÿã€æ˜¯ã€‘

closure:å‡½æ•°æŒ‡é’ˆï¼Œé—­åŒ…ã€‚

![image-20230420195551915](./4-19/image-20230420195551915.png)



ä¼¼ä¹åœ¨rocksdbé‡Œé¢ï¼Œpriotableä¸æ­¢å¯ä»¥è¿›è¡Œagentå’Œclientçš„äº¤äº’ï¼Œè¿˜è´Ÿè´£çº¿ç¨‹é—´çš„é€šä¿¡ï¼ˆghostä¹‹é—´ã€agentä¸ghostä¹‹é—´ã€ghostä¸CFSä¹‹é—´ï¼ˆload generatorä¸workerï¼‰ï¼‰ï¼Œåä¸¤è€…æ˜¯ä¸»è¦çš„

![image-20230421105556287](./4-19/image-20230421105556287.png)





![image-20230421115617870](./4-19/image-20230421115617870.png)

è¯´çš„ä»€ä¹ˆç©æ„





è¿›åº¦ï¼šçœ‹å®Œäº†orä»€ä¹ˆç©æ„çš„æ–¹æ³•ï¼Œä»Šå¤©/æ˜å¤©ï¼ˆå¤§æ¦‚ç‡æ˜¯ä»Šæ™šå’Œæ˜æ™šï¼‰ä»å¤´åˆ°å°¾æ¢³ç†éã€‚

